"""
Report Generation Module
Milestone 4 - Week 7-8

Generates professional, customized reports from contract analysis results.
Supports multiple formats: Markdown, PDF, JSON
"""

from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
import json


class ReportTone(Enum):
    """Report tone options"""
    PROFESSIONAL = "professional"
    TECHNICAL = "technical"
    EXECUTIVE = "executive"
    DETAILED = "detailed"


class ReportFormat(Enum):
    """Report output formats"""
    MARKDOWN = "markdown"
    JSON = "json"
    HTML = "html"
    PDF = "pdf"
    DOCX = "docx"


@dataclass
class ReportOptions:
    """Configuration options for report generation"""
    tone: ReportTone = ReportTone.PROFESSIONAL
    format: ReportFormat = ReportFormat.MARKDOWN
    include_clauses: bool = True
    include_risks: bool = True
    include_discussions: bool = True
    include_recommendations: bool = True
    focus_areas: List[str] = None  # ['compliance', 'finance', 'legal', 'operations']
    
    def __post_init__(self):
        if self.focus_areas is None:
            self.focus_areas = ['compliance', 'finance', 'legal', 'operations']


class ReportGenerator:
    """
    Generate customized reports from contract analysis results
    Milestone 4: Automated summary creation with customization
    """
    
    def __init__(self, options: Optional[ReportOptions] = None):
        self.options = options or ReportOptions()
    
    def generate_report(self, analysis_results: Dict) -> str:
        """
        Generate complete report from analysis results
        
        Args:
            analysis_results: Dictionary containing all analysis outputs
            
        Returns:
            Formatted report string or bytes for binary formats
        """
        if self.options.format == ReportFormat.MARKDOWN:
            return self._generate_markdown_report(analysis_results)
        elif self.options.format == ReportFormat.JSON:
            return self._generate_json_report(analysis_results)
        elif self.options.format == ReportFormat.HTML:
            return self._generate_html_report(analysis_results)
        elif self.options.format == ReportFormat.PDF:
            return self._generate_pdf_report(analysis_results)
        elif self.options.format == ReportFormat.DOCX:
            return self._generate_docx_report(analysis_results)
        else:
            return self._generate_markdown_report(analysis_results)
    
    def _generate_markdown_report(self, results: Dict) -> str:
        """Generate professional Markdown report"""
        report_parts = []
        
        # Header
        report_parts.append(self._generate_header(results))
        
        # Risk Score Summary (NEW)
        if results.get('risk_scores'):
            report_parts.append(self._generate_risk_scores_section(results))
        
        # Missing Clauses (NEW)
        if results.get('missing_clauses'):
            report_parts.append(self._generate_missing_clauses_section(results))
        
        # Executive Summary (always included)
        report_parts.append(self._generate_executive_summary(results))
        
        # Key Findings
        report_parts.append(self._generate_key_findings(results))
        
        # Extracted Clauses
        if self.options.include_clauses and results.get('extracted_clauses'):
            report_parts.append(self._generate_clauses_section(results))
        
        # Risk Analysis
        if self.options.include_risks and results.get('identified_risks'):
            report_parts.append(self._generate_risks_section(results))
        
        # Domain-Specific Analysis
        report_parts.append(self._generate_domain_analysis(results))
        
        # Agent Discussions
        if self.options.include_discussions and results.get('discussion_summaries'):
            report_parts.append(self._generate_discussions_section(results))
        
        # Recommendations
        if self.options.include_recommendations:
            report_parts.append(self._generate_recommendations(results))
        
        # Footer
        report_parts.append(self._generate_footer())
        
        return "\n\n".join(report_parts)
    
    def _generate_header(self, results: Dict) -> str:
        """Generate report header"""
        contract_id = results.get('contract_id', 'Unknown')
        timestamp = datetime.now().strftime("%B %d, %Y at %I:%M %p")
        
        header = f"""# ClauseAI Contract Analysis Report

**Contract ID:** {contract_id}  
**Analysis Date:** {timestamp}  
**Report Type:** {self.options.tone.value.title()}  
**Generated by:** ClauseAI Multi-Agent System

---
"""
        return header
    
    def _generate_risk_scores_section(self, results: Dict) -> str:
        """Generate risk scoring summary section (NEW)"""
        risk_scores = results.get('risk_scores', {})
        
        if not risk_scores:
            return ""
        
        overall_score = risk_scores.get('overall_score', 0.0)
        overall_level = risk_scores.get('overall_level', 'LOW RISK')
        domain_scores = risk_scores.get('domain_scores', {})
        severity_breakdown = risk_scores.get('severity_breakdown', {})
        missing_penalty = risk_scores.get('missing_clause_penalty', 0.0)
        
        # Get risk level emoji
        level_emoji = {
            'CRITICAL RISK': 'ðŸ”´',
            'HIGH RISK': 'ðŸŸ ',
            'MEDIUM RISK': 'ðŸŸ¡',
            'LOW RISK': 'ðŸŸ¢'
        }.get(overall_level, 'âšª')
        
        section = f"""## ðŸ“Š Risk Scoring Analysis

### Overall Risk Score: **{overall_score} / 10** {level_emoji} **({overall_level})**

#### Domain Risk Breakdown:
- **Compliance Risk:** {domain_scores.get('compliance', 0.0)} / 10
- **Financial Risk:** {domain_scores.get('financial', 0.0)} / 10
- **Legal Risk:** {domain_scores.get('legal', 0.0)} / 10
- **Operational Risk:** {domain_scores.get('operational', 0.0)} / 10

#### Severity Distribution:
- ðŸ”´ **Critical:** {severity_breakdown.get('critical', 0)} risks
- ðŸŸ  **High:** {severity_breakdown.get('high', 0)} risks
- ðŸŸ¡ **Medium:** {severity_breakdown.get('medium', 0)} risks
- ðŸŸ¢ **Low:** {severity_breakdown.get('low', 0)} risks

"""
        if missing_penalty > 0:
            section += f"âš ï¸ **Missing Clause Penalty:** +{missing_penalty:.1f} points added to score due to critical missing clauses.\n\n"
        
        section += """#### Risk Level Guide:
- **0-3.9:** Low Risk - Standard contract with minimal concerns
- **4.0-5.9:** Medium Risk - Requires careful review
- **6.0-7.9:** High Risk - Significant issues need negotiation
- **8.0-10.0:** Critical Risk - Major concerns requiring immediate attention

"""
        return section
    
    def _generate_missing_clauses_section(self, results: Dict) -> str:
        """Generate missing clauses section (NEW)"""
        missing_clauses = results.get('missing_clauses', [])
        missing_summary = results.get('missing_clause_summary', {})
        
        if not missing_clauses:
            return """## âœ… Missing Clause Analysis

**All Critical Clauses Present!**

This contract includes all essential clauses for comprehensive protection. No critical missing clauses detected.

"""
        
        total_missing = missing_summary.get('total_missing', len(missing_clauses))
        critical_missing = missing_summary.get('critical_missing', 0)
        high_missing = missing_summary.get('high_missing', 0)
        medium_missing = missing_summary.get('medium_missing', 0)
        completion_score = missing_summary.get('completion_score', 100)
        
        section = f"""## âŒ Missing Critical Clauses

**Contract Completeness Score:** {completion_score:.0f}%

### Summary:
- ðŸ”´ **Critical Missing:** {critical_missing}
- ðŸŸ  **High Priority Missing:** {high_missing}
- ðŸŸ¡ **Medium Priority Missing:** {medium_missing}
- **Total Missing:** {total_missing}

### Missing Clauses by Priority:

"""
        # Group by importance
        critical_clauses = [c for c in missing_clauses if c.get('importance') == 'CRITICAL']
        high_clauses = [c for c in missing_clauses if c.get('importance') == 'HIGH']
        medium_clauses = [c for c in missing_clauses if c.get('importance') == 'MEDIUM']
        
        if critical_clauses:
            section += "#### ðŸ”´ Critical Missing Clauses\n\n"
            for clause in critical_clauses:
                section += f"**âŒ {clause.get('clause_name')}**\n"
                section += f"- **Category:** {clause.get('category', '').title()}\n"
                section += f"- **Why It Matters:** {clause.get('reason')}\n"
                section += f"- **Recommendation:** {clause.get('recommendation')}\n\n"
        
        if high_clauses:
            section += "#### ðŸŸ  High Priority Missing Clauses\n\n"
            for clause in high_clauses:
                section += f"**âŒ {clause.get('clause_name')}**\n"
                section += f"- **Category:** {clause.get('category', '').title()}\n"
                section += f"- **Recommendation:** {clause.get('recommendation')}\n\n"
        
        if medium_clauses:
            section += "#### ðŸŸ¡ Medium Priority Missing Clauses\n\n"
            for clause in medium_clauses:
                section += f"**âŒ {clause.get('clause_name')}**  \n"
                section += f"{clause.get('recommendation')}\n\n"
        
        return section
    
    def _generate_executive_summary(self, results: Dict) -> str:
        """Generate executive summary section"""
        summary = results.get('final_summary', 'No summary available')
        
        return f"""## ðŸ“‹ Executive Summary

{summary}
"""
    
    def _generate_key_findings(self, results: Dict) -> str:
        """Generate key findings overview"""
        clause_count = len(results.get('extracted_clauses', []))
        risk_count = len(results.get('identified_risks', []))
        discussion_count = len(results.get('discussion_summaries', []))
        
        # Count risks by severity
        risks_by_severity = {
            'Critical': 0,
            'High': 0,
            'Medium': 0,
            'Low': 0
        }
        
        for risk in results.get('identified_risks', []):
            severity = risk.get('severity', 'Medium')
            if isinstance(severity, dict):
                severity = severity.get('value', 'Medium')
            risks_by_severity[severity] = risks_by_severity.get(severity, 0) + 1
        
        findings = f"""## ðŸ” Key Findings

### Analysis Overview
- **Total Clauses Extracted:** {clause_count}
- **Risks Identified:** {risk_count}
  - ðŸ”´ Critical: {risks_by_severity['Critical']}
  - ðŸŸ  High: {risks_by_severity['High']}
  - ðŸŸ¡ Medium: {risks_by_severity['Medium']}
  - ðŸŸ¢ Low: {risks_by_severity['Low']}
- **Agent Discussions:** {discussion_count}
- **Contract Type:** {results.get('contract_type', 'General')}
"""
        return findings
    
    def _generate_clauses_section(self, results: Dict) -> str:
        """Generate extracted clauses section"""
        clauses = results.get('extracted_clauses', [])
        
        if not clauses:
            return ""
        
        # Group clauses by type
        clauses_by_type = {}
        for clause in clauses:
            clause_type = clause.get('type', 'General')
            if clause_type not in clauses_by_type:
                clauses_by_type[clause_type] = []
            clauses_by_type[clause_type].append(clause)
        
        section = "## ðŸ“„ Extracted Clauses\n\n"
        
        for clause_type, type_clauses in sorted(clauses_by_type.items()):
            section += f"### {clause_type.title()} ({len(type_clauses)})\n\n"
            for i, clause in enumerate(type_clauses, 1):
                text = clause.get('text', clause) if isinstance(clause, dict) else clause
                section += f"{i}. {text}\n\n"
        
        return section
    
    def _generate_risks_section(self, results: Dict) -> str:
        """Generate risk analysis section"""
        risks = results.get('identified_risks', [])
        
        if not risks:
            return ""
        
        section = "## âš ï¸ Risk Analysis\n\n"
        
        # Sort by severity
        severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}
        sorted_risks = sorted(risks, key=lambda r: severity_order.get(
            r.get('severity') if isinstance(r.get('severity'), str) else r.get('severity', {}).get('value', 'Medium'), 
            2))
        
        for i, risk in enumerate(sorted_risks, 1):
            severity = risk.get('severity', 'Medium')
            if isinstance(severity, dict):
                severity = severity.get('value', 'Medium')
            
            category = risk.get('category', risk.get('type', 'General Risk'))
            description = risk.get('description', risk.get('text', str(risk)))
            
            severity_emoji = {
                'Critical': 'ðŸ”´',
                'High': 'ðŸŸ ',
                'Medium': 'ðŸŸ¡',
                'Low': 'ðŸŸ¢'
            }.get(severity, 'âšª')
            
            section += f"### {severity_emoji} Risk {i}: {category}\n\n"
            section += f"**Severity:** {severity}  \n"
            section += f"**Description:** {description}\n\n"
            
            if isinstance(risk, dict):
                if risk.get('recommendation'):
                    section += f"**Recommendation:** {risk['recommendation']}\n\n"
        
        return section
    
    def _generate_domain_analysis(self, results: Dict) -> str:
        """Generate domain-specific analysis sections"""
        section = "## ðŸŽ¯ Domain-Specific Analysis\n\n"
        
        domains = {
            'compliance': ('ðŸ“‹ Compliance Analysis', results.get('compliance_analysis')),
            'finance': ('ðŸ’° Finance Analysis', results.get('finance_analysis')),
            'legal': ('âš–ï¸ Legal Analysis', results.get('legal_analysis')),
            'operations': ('ðŸ”§ Operations Analysis', results.get('operations_analysis'))
        }
        
        for domain_key, (title, content) in domains.items():
            if domain_key in self.options.focus_areas and content:
                section += f"### {title}\n\n{content}\n\n"
        
        return section
    
    def _generate_discussions_section(self, results: Dict) -> str:
        """Generate agent discussions section"""
        discussions = results.get('discussion_summaries', [])
        
        if not discussions:
            return ""
        
        section = "## ðŸ’¬ Agent Discussions\n\n"
        section += "*Multi-turn interactions where agents clarified ambiguities*\n\n"
        
        for i, discussion in enumerate(discussions, 1):
            section += f"### Discussion {i}\n\n"
            section += f"{discussion}\n\n"
        
        return section
    
    def _generate_recommendations(self, results: Dict) -> str:
        """Generate recommendations section"""
        section = "## ðŸ’¡ Recommendations\n\n"
        
        # Extract recommendations from risks
        recommendations = []
        for risk in results.get('identified_risks', []):
            if isinstance(risk, dict) and risk.get('recommendation'):
                recommendations.append(risk['recommendation'])
        
        if recommendations:
            section += "### Risk Mitigation\n\n"
            for i, rec in enumerate(recommendations, 1):
                section += f"{i}. {rec}\n"
            section += "\n"
        
        # General recommendations based on tone
        if self.options.tone == ReportTone.EXECUTIVE:
            section += """### Executive Actions
1. Review critical risks with legal counsel
2. Negotiate terms for high-severity issues
3. Establish monitoring procedures for compliance
4. Schedule follow-up review in 90 days
"""
        elif self.options.tone == ReportTone.TECHNICAL:
            section += """### Technical Considerations
1. Implement automated monitoring for key clauses
2. Set up alerts for payment deadlines and renewals
3. Document all assumptions and interpretations
4. Create compliance checklist based on identified requirements
"""
        else:
            section += """### Next Steps
1. Address all critical and high-severity risks
2. Clarify ambiguous terms with the other party
3. Ensure compliance with identified regulatory requirements
4. Establish regular review schedule
"""
        
        return section
    
    def _generate_footer(self) -> str:
        """Generate report footer"""
        return """---

**Disclaimer:** This analysis is generated by AI and should be reviewed by qualified legal professionals. 
It does not constitute legal advice.

*Generated by ClauseAI - Multi-Agent Legal Contract Analyzer*
"""
    
    def _generate_json_report(self, results: Dict) -> str:
        """Generate JSON format report"""
        report_data = {
            'metadata': {
                'contract_id': results.get('contract_id'),
                'timestamp': datetime.now().isoformat(),
                'report_type': self.options.tone.value,
                'generator': 'ClauseAI'
            },
            'analysis': results
        }
        return json.dumps(report_data, indent=2)
    
    def _generate_html_report(self, results: Dict) -> str:
        """Generate HTML format report"""
        markdown_content = self._generate_markdown_report(results)
        
        # Simple HTML wrapper
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ClauseAI Report - {results.get('contract_id', 'Unknown')}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 900px;
            margin: 50px auto;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }}
        h1 {{ color: #2563eb; }}
        h2 {{ color: #1e40af; border-bottom: 2px solid #e5e7eb; padding-bottom: 10px; }}
        h3 {{ color: #475569; }}
        code {{ background: #f1f5f9; padding: 2px 5px; border-radius: 3px; }}
        pre {{ background: #f1f5f9; padding: 15px; border-radius: 5px; overflow-x: auto; }}
        .risk-critical {{ border-left: 4px solid #ef4444; padding-left: 15px; }}
        .risk-high {{ border-left: 4px solid #f59e0b; padding-left: 15px; }}
        .risk-medium {{ border-left: 4px solid #eab308; padding-left: 15px; }}
        .risk-low {{ border-left: 4px solid #10b981; padding-left: 15px; }}
    </style>
</head>
<body>
    <pre>{markdown_content}</pre>
</body>
</html>"""
        return html
    
    def _generate_pdf_report(self, results: Dict) -> bytes:
        """Generate PDF report from markdown content"""
        try:
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, Table, TableStyle
            from reportlab.lib import colors
            from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY
            import io
            
            # Generate markdown content first
            markdown_content = self._generate_markdown_report(results)
            
            # Create PDF in memory
            buffer = io.BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=letter,
                                  rightMargin=0.75*inch, leftMargin=0.75*inch,
                                  topMargin=1*inch, bottomMargin=0.75*inch)
            
            # Container for PDF elements
            story = []
            
            # Get styles
            styles = getSampleStyleSheet()
            
            # Custom styles
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                textColor=colors.HexColor('#4F46E5'),
                spaceAfter=30,
                alignment=TA_CENTER,
                fontName='Helvetica-Bold'
            )
            
            heading1_style = ParagraphStyle(
                'CustomHeading1',
                parent=styles['Heading1'],
                fontSize=16,
                textColor=colors.HexColor('#1F2937'),
                spaceAfter=12,
                spaceBefore=12,
                fontName='Helvetica-Bold'
            )
            
            heading2_style = ParagraphStyle(
                'CustomHeading2',
                parent=styles['Heading2'],
                fontSize=14,
                textColor=colors.HexColor('#374151'),
                spaceAfter=8,
                spaceBefore=8,
                fontName='Helvetica-Bold'
            )
            
            body_style = ParagraphStyle(
                'CustomBody',
                parent=styles['BodyText'],
                fontSize=11,
                textColor=colors.HexColor('#1F2937'),
                alignment=TA_JUSTIFY,
                spaceAfter=8
            )
            
            # Parse markdown and add to PDF
            lines = markdown_content.split('\n')
            for line in lines:
                line = line.strip()
                
                if not line:
                    story.append(Spacer(1, 0.1*inch))
                    continue
                
                # Title (# header)
                if line.startswith('# '):
                    story.append(Paragraph(line[2:], title_style))
                    story.append(Spacer(1, 0.2*inch))
                
                # Heading 1 (## header)
                elif line.startswith('## '):
                    story.append(Spacer(1, 0.15*inch))
                    story.append(Paragraph(line[3:], heading1_style))
                
                # Heading 2 (### header)
                elif line.startswith('### '):
                    story.append(Paragraph(line[4:], heading2_style))
                
                # Horizontal rule
                elif line.startswith('---'):
                    story.append(Spacer(1, 0.1*inch))
                    story.append(Table([['']], colWidths=[7*inch], 
                                     style=[('LINEABOVE', (0,0), (-1,0), 1, colors.grey)]))
                    story.append(Spacer(1, 0.1*inch))
                
                # Bullet points
                elif line.startswith('- ') or line.startswith('* '):
                    story.append(Paragraph('â€¢ ' + line[2:], body_style))
                
                # Numbered lists
                elif len(line) > 2 and line[0].isdigit() and line[1:3] == '. ':
                    story.append(Paragraph(line, body_style))
                
                # Bold text **text** â†’ <b>text</b>
                elif '**' in line:
                    formatted_line = line.replace('**', '<b>', 1).replace('**', '</b>', 1)
                    while '**' in formatted_line:
                        formatted_line = formatted_line.replace('**', '<b>', 1).replace('**', '</b>', 1)
                    story.append(Paragraph(formatted_line, body_style))
                
                # Regular paragraph
                elif line and not line.startswith('#'):
                    story.append(Paragraph(line, body_style))
            
            # Build PDF
            doc.build(story)
            
            # Get PDF bytes
            pdf_bytes = buffer.getvalue()
            buffer.close()
            
            return pdf_bytes
            
        except Exception as e:
            print(f"[ERROR] PDF generation failed: {e}")
            # Fallback to markdown if PDF fails
            return self._generate_markdown_report(results).encode('utf-8')
    
    def _generate_docx_report(self, results: Dict) -> bytes:
        """Generate Word DOCX report from markdown content"""
        try:
            from docx import Document
            from docx.shared import Inches, Pt, RGBColor
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            import io
            
            # Generate markdown content first
            markdown_content = self._generate_markdown_report(results)
            
            # Create Word document
            doc = Document()
            
            # Set document margins
            sections = doc.sections
            for section in sections:
                section.top_margin = Inches(1)
                section.bottom_margin = Inches(1)
                section.left_margin = Inches(1)
                section.right_margin = Inches(1)
            
            # Parse markdown and add to Word doc
            lines = markdown_content.split('\n')
            
            for line in lines:
                line = line.strip()
                
                if not line:
                    continue
                
                # Title (# header)
                if line.startswith('# '):
                    heading = doc.add_heading(line[2:], level=0)
                    heading.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    run = heading.runs[0]
                    run.font.color.rgb = RGBColor(79, 70, 229)  # Indigo
                    run.font.size = Pt(24)
                
                # Heading 1 (## header)
                elif line.startswith('## '):
                    heading = doc.add_heading(line[3:], level=1)
                    run = heading.runs[0]
                    run.font.color.rgb = RGBColor(31, 41, 55)  # Dark gray
                    run.font.size = Pt(16)
                
                # Heading 2 (### header)
                elif line.startswith('### '):
                    heading = doc.add_heading(line[4:], level=2)
                    run = heading.runs[0]
                    run.font.color.rgb = RGBColor(55, 65, 81)
                    run.font.size = Pt(14)
                
                # Heading 3 (#### header)
                elif line.startswith('#### '):
                    heading = doc.add_heading(line[5:], level=3)
                    run = heading.runs[0]
                    run.font.size = Pt(12)
                
                # Horizontal rule
                elif line.startswith('---'):
                    doc.add_paragraph('_' * 60)
                
                # Bullet points
                elif line.startswith('- ') or line.startswith('* '):
                    p = doc.add_paragraph(line[2:], style='List Bullet')
                    p.paragraph_format.left_indent = Inches(0.25)
                
                # Numbered lists
                elif len(line) > 2 and line[0].isdigit() and line[1:3] == '. ':
                    p = doc.add_paragraph(line[3:], style='List Number')
                    p.paragraph_format.left_indent = Inches(0.25)
                
                # Regular paragraph with bold formatting
                elif line and not line.startswith('#'):
                    p = doc.add_paragraph()
                    
                    # Handle bold text **text**
                    parts = line.split('**')
                    for i, part in enumerate(parts):
                        if i % 2 == 0:  # Regular text
                            if part:
                                run = p.add_run(part)
                                run.font.size = Pt(11)
                        else:  # Bold text
                            if part:
                                run = p.add_run(part)
                                run.bold = True
                                run.font.size = Pt(11)
            
            # Save to bytes buffer
            buffer = io.BytesIO()
            doc.save(buffer)
            docx_bytes = buffer.getvalue()
            buffer.close()
            
            return docx_bytes
            
        except Exception as e:
            print(f"[ERROR] DOCX generation failed: {e}")
            # Fallback to markdown if DOCX fails
            return self._generate_markdown_report(results).encode('utf-8')
    
    def save_report(self, report_content: str, filename: str) -> str:
        """
        Save report to file
        
        Args:
            report_content: Generated report content
            filename: Output filename
            
        Returns:
            Path to saved file
        """
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        return filename


if __name__ == "__main__":
    print("Report Generation Module - Milestone 4")
    print("=" * 60)
    print("Capabilities:")
    print("  - Multiple report tones (Professional, Technical, Executive, Detailed)")
    print("  - Multiple formats (Markdown, JSON, HTML)")
    print("  - Customizable sections")
    print("  - Focus area filtering")
    print("  - Risk prioritization")
    print("  - Automated recommendations")
